import type { AdasDatabase } from "@repo/db";
import { schema } from "@repo/db";
import { eq, isNotNull, sql } from "drizzle-orm";
import { Hono } from "hono";
import {
  deleteSpeaker,
  loadRegisteredEmbeddings,
  loadSpeakerMetadata,
  renameSpeaker,
} from "../../whisper/speaker-store.js";

export function createSpeakersRouter(db: AdasDatabase) {
  const router = new Hono();

  // GET / - 全話者一覧(embeddings + DB の distinct speaker を結合)
  router.get("/", (c) => {
    const embeddings = loadRegisteredEmbeddings();
    const metadata = loadSpeakerMetadata();

    // embeddings に登録されている話者
    const speakerMap = new Map<
      string,
      {
        name: string;
        autoGenerated: boolean;
        firstSeen: string | null;
        lastSeen: string | null;
        sampleTexts: string[];
        occurrenceCount: number;
        hasEmbedding: boolean;
      }
    >();

    for (const name of Object.keys(embeddings)) {
      const meta = metadata[name];
      speakerMap.set(name, {
        name,
        autoGenerated: meta?.autoGenerated ?? false,
        firstSeen: meta?.firstSeen ?? null,
        lastSeen: meta?.lastSeen ?? null,
        sampleTexts: meta?.sampleTexts ?? [],
        occurrenceCount: meta?.occurrenceCount ?? 0,
        hasEmbedding: true,
      });
    }

    // DB に存在する話者ラベルも追加(embedding 未登録のもの)
    const dbSpeakers = db
      .selectDistinct({ speaker: schema.transcriptionSegments.speaker })
      .from(schema.transcriptionSegments)
      .where(isNotNull(schema.transcriptionSegments.speaker))
      .all();

    for (const row of dbSpeakers) {
      if (row.speaker && !speakerMap.has(row.speaker)) {
        // DB のみに存在する話者 → 出現回数を取得
        const countResult = db
          .select({ count: sql<number>`count(*)` })
          .from(schema.transcriptionSegments)
          .where(eq(schema.transcriptionSegments.speaker, row.speaker))
          .get();
        speakerMap.set(row.speaker, {
          name: row.speaker,
          autoGenerated: true,
          firstSeen: null,
          lastSeen: null,
          sampleTexts: [],
          occurrenceCount: countResult?.count ?? 0,
          hasEmbedding: false,
        });
      }
    }

    return c.json(Array.from(speakerMap.values()));
  });

  // POST /rename - 話者リネーム + DB 一括更新
  router.post("/rename", async (c) => {
    const body = await c.req.json<{ oldName: string; newName: string }>();

    if (!body.oldName?.trim() || !body.newName?.trim()) {
      return c.json({ error: "oldName and newName are required" }, 400);
    }

    const oldName = body.oldName.trim();
    const newName = body.newName.trim();

    if (oldName === newName) {
      return c.json({ error: "oldName and newName must be different" }, 400);
    }

    // embedding がある話者はファイルのキーも差替え
    renameSpeaker(oldName, newName);

    // DB の speaker カラムを一括更新
    db.update(schema.transcriptionSegments)
      .set({ speaker: newName })
      .where(eq(schema.transcriptionSegments.speaker, oldName))
      .run();

    return c.json({ success: true, oldName, newName });
  });

  // DELETE /:name - 話者を削除(embedding + DB の speaker を null に)
  router.delete("/:name", (c) => {
    const name = decodeURIComponent(c.req.param("name"));

    // embedding がある場合はファイルから削除
    deleteSpeaker(name);

    // DB の speaker カラムを null に更新
    db.update(schema.transcriptionSegments)
      .set({ speaker: null })
      .where(eq(schema.transcriptionSegments.speaker, name))
      .run();

    return c.json({ success: true, deletedName: name });
  });

  return router;
}

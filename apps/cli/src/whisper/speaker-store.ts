import { existsSync, readFileSync, writeFileSync } from "node:fs";
import { join } from "node:path";
import consola from "consola";
import { ensureAdasHome, getAdasHome } from "../config.js";

const UNKNOWN_SPEAKERS_FILENAME = "unknown_speakers.json";
const EMBEDDINGS_FILENAME = "speaker_embeddings.json";
const METADATA_FILENAME = "speaker_metadata.json";
const SIMILARITY_THRESHOLD = 0.5;

export interface UnknownSpeaker {
  embedding: number[];
  firstSeen: string;
  lastSeen: string;
  sampleTexts: string[];
  occurrenceCount: number;
}

export interface SpeakerMetadata {
  autoGenerated: boolean;
  firstSeen: string;
  lastSeen: string;
  sampleTexts: string[];
  occurrenceCount: number;
}

export type UnknownSpeakersStore = Record<string, UnknownSpeaker>;
export type RegisteredEmbeddingsStore = Record<string, number[]>;
export type SpeakerMetadataStore = Record<string, SpeakerMetadata>;

function getUnknownSpeakersPath(): string {
  return join(getAdasHome(), UNKNOWN_SPEAKERS_FILENAME);
}

export function loadUnknownSpeakers(): UnknownSpeakersStore {
  const path = getUnknownSpeakersPath();
  if (!existsSync(path)) {
    return {};
  }
  const raw = readFileSync(path, "utf-8");
  return JSON.parse(raw) as UnknownSpeakersStore;
}

export function saveUnknownSpeakers(store: UnknownSpeakersStore): void {
  ensureAdasHome();
  const path = getUnknownSpeakersPath();
  writeFileSync(path, JSON.stringify(store, null, 2));
}

function getRegisteredEmbeddingsPath(): string {
  return join(getAdasHome(), EMBEDDINGS_FILENAME);
}

export function loadRegisteredEmbeddings(): RegisteredEmbeddingsStore {
  const path = getRegisteredEmbeddingsPath();
  if (!existsSync(path)) {
    return {};
  }
  const raw = readFileSync(path, "utf-8");
  return JSON.parse(raw) as RegisteredEmbeddingsStore;
}

export function saveRegisteredEmbeddings(store: RegisteredEmbeddingsStore): void {
  ensureAdasHome();
  const path = getRegisteredEmbeddingsPath();
  writeFileSync(path, JSON.stringify(store, null, 2));
}

function getMetadataPath(): string {
  return join(getAdasHome(), METADATA_FILENAME);
}

export function loadSpeakerMetadata(): SpeakerMetadataStore {
  const path = getMetadataPath();
  if (!existsSync(path)) {
    return {};
  }
  const raw = readFileSync(path, "utf-8");
  return JSON.parse(raw) as SpeakerMetadataStore;
}

export function saveSpeakerMetadata(store: SpeakerMetadataStore): void {
  ensureAdasHome();
  const path = getMetadataPath();
  writeFileSync(path, JSON.stringify(store, null, 2));
}

function cosineSimilarity(a: number[], b: number[]): number {
  if (a.length !== b.length || a.length === 0) return 0;
  let dot = 0;
  let normA = 0;
  let normB = 0;
  for (let i = 0; i < a.length; i++) {
    dot += a[i]! * b[i]!;
    normA += a[i]! * a[i]!;
    normB += b[i]! * b[i]!;
  }
  if (normA === 0 || normB === 0) return 0;
  return dot / (Math.sqrt(normA) * Math.sqrt(normB));
}

/**
 * 既存の Speaker N の最大番号を取得し、次の番号を返す。
 */
function getNextSpeakerNumber(embeddingsStore: RegisteredEmbeddingsStore): number {
  let maxNum = 0;
  for (const name of Object.keys(embeddingsStore)) {
    const match = name.match(/^Speaker (\d+)$/);
    if (match) {
      const num = Number.parseInt(match[1]!, 10);
      if (num > maxNum) maxNum = num;
    }
  }
  return maxNum + 1;
}

/**
 * 登録済み話者の embedding と照合して、最も類似する話者名を返す。
 * マッチしなければ null を返す。
 */
function findMatchingSpeaker(
  emb: number[],
  registeredEmbeddings: Record<string, number[]>,
): string | null {
  let bestName: string | null = null;
  let bestScore = -1;
  for (const [name, regEmb] of Object.entries(registeredEmbeddings)) {
    const score = cosineSimilarity(emb, regEmb);
    if (score > bestScore) {
      bestScore = score;
      bestName = name;
    }
  }
  if (bestName && bestScore >= SIMILARITY_THRESHOLD) {
    return bestName;
  }
  return null;
}

/**
 * 話者 embedding を処理し、元ラベル → 登録名のマッピングを返す。
 *
 * - 登録済み話者にマッチ → そのまま登録名を返す(メタデータ更新)
 * - 未知話者 → Speaker N で即座に speaker_embeddings.json に登録し、メタデータも保存
 *
 * @returns Record<string, string> - 元ラベル → 登録名のマッピング
 */
export function accumulateSpeakerEmbeddings(
  embeddings: Record<string, number[]>,
  speakerTexts: Record<string, string[]>,
  registeredEmbeddings: Record<string, number[]>,
): Record<string, string> {
  const labelMap: Record<string, string> = {};
  const metadata = loadSpeakerMetadata();
  const now = new Date().toISOString();
  let embeddingsUpdated = false;
  let nextNum = getNextSpeakerNumber(registeredEmbeddings);

  for (const [label, emb] of Object.entries(embeddings)) {
    if (!emb) continue;
    const texts = speakerTexts[label] ?? [];

    const matchedName = findMatchingSpeaker(emb, registeredEmbeddings);
    if (matchedName) {
      // 登録済み話者にマッチ
      labelMap[label] = matchedName;
      // メタデータ更新
      const meta = metadata[matchedName];
      if (meta) {
        meta.lastSeen = now;
        meta.occurrenceCount += 1;
        for (const t of texts) {
          if (meta.sampleTexts.length < 10 && !meta.sampleTexts.includes(t)) {
            meta.sampleTexts.push(t);
          }
        }
      } else {
        metadata[matchedName] = {
          autoGenerated: false,
          firstSeen: now,
          lastSeen: now,
          sampleTexts: texts.slice(0, 10),
          occurrenceCount: 1,
        };
      }
      // embedding を最新に更新
      registeredEmbeddings[matchedName] = emb;
      embeddingsUpdated = true;
      consola.debug(`Matched speaker ${label} to ${matchedName}`);
    } else {
      // 未知話者 → 仮名で即登録
      const newName = `Speaker ${nextNum}`;
      nextNum++;
      registeredEmbeddings[newName] = emb;
      embeddingsUpdated = true;
      metadata[newName] = {
        autoGenerated: true,
        firstSeen: now,
        lastSeen: now,
        sampleTexts: texts.slice(0, 10),
        occurrenceCount: 1,
      };
      labelMap[label] = newName;
      consola.debug(`New speaker ${label} registered as ${newName}`);
    }
  }

  if (embeddingsUpdated) {
    saveRegisteredEmbeddings(registeredEmbeddings);
  }
  saveSpeakerMetadata(metadata);

  return labelMap;
}

/**
 * 話者の名前を変更する。embeddings + metadata のキーを差替え。
 */
export function renameSpeaker(oldName: string, newName: string): boolean {
  const embeddings = loadRegisteredEmbeddings();
  if (!embeddings[oldName]) return false;
  if (embeddings[newName]) return false; // 既に存在する名前には変更不可

  embeddings[newName] = embeddings[oldName]!;
  delete embeddings[oldName];
  saveRegisteredEmbeddings(embeddings);

  const metadata = loadSpeakerMetadata();
  if (metadata[oldName]) {
    metadata[newName] = { ...metadata[oldName]!, autoGenerated: false };
    delete metadata[oldName];
    saveSpeakerMetadata(metadata);
  }

  return true;
}

/**
 * 話者を削除する。embeddings + metadata から削除。
 */
export function deleteSpeaker(name: string): boolean {
  const embeddings = loadRegisteredEmbeddings();
  if (!embeddings[name]) return false;

  delete embeddings[name];
  saveRegisteredEmbeddings(embeddings);

  const metadata = loadSpeakerMetadata();
  if (metadata[name]) {
    delete metadata[name];
    saveSpeakerMetadata(metadata);
  }

  return true;
}
